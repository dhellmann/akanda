1c1
< # Copyright (c) 2012 OpenStack, LLC.
---
> # -*- encoding: utf-8 -*-
3,5c3
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
---
> # Copyright Â© 2012 New Dream Network, LLC (DreamHost)
7c5,7
< #    http://www.apache.org/licenses/LICENSE-2.0
---
> # Licensed under the Apache License, Version 2.0 (the "License"); you may
> # not use this file except in compliance with the License. You may obtain
> # a copy of the License at
9,14c9
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
< # implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
---
> #      http://www.apache.org/licenses/LICENSE-2.0
16,17c11,15
< # DreamHost Qauntum Extensions
< # Copyright 2012 New Dream Network, LLC (DreamHost)
---
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
> # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
> # License for the specific language governing permissions and limitations
> # under the License.
33d30
< from quantum.common import utils
34a32
> from quantum.db import models_v2 as models
37a36
> BASE = model_base.BASE
41,187d39
< class Validator:
< 
<     #VALIDATORS
<     #Validate private and public port ranges
<     '''Consider moving the following to some shared
<     attributes class'''
< 
<     #Used by type() regex to check if IDs are UUID
<     HEX_ELEM = '[0-9A-Fa-f]'
<     UUID_PATTERN = '-'.join([HEX_ELEM + '{8}', HEX_ELEM + '{4}',
<                              HEX_ELEM + '{4}', HEX_ELEM + '{4}',
<                              HEX_ELEM + '{12}'])
< 
< 
< class HasTenant(object):
<     """Tenant mixin, add to subclasses that have a tenant."""
<     # NOTE(jkoelker) tenant_id is just a free form string ;(
<     tenant_id = sa.Column(sa.String(255))
< 
< 
< class HasId(object):
<     """id mixin, add to subclasses that have an id."""
<     id = sa.Column(sa.String(36), primary_key=True, default=utils.str_uuid)
< 
< 
< class IPAvailabilityRange(model_base.BASEV2):
<     """Internal representation of available IPs for Quantum subnets.
< 
<     Allocation - first entry from the range will be allocated.
<     If the first entry is equal to the last entry then this row
<     will be deleted.
<     Recycling ips involves appending to existing ranges. This is
<     only done if the range is contiguous. If not, the first_ip will be
<     the same as the last_ip. When adjacent ips are recycled the ranges
<     will be merged.
< 
<     """
<     allocation_pool_id = sa.Column(sa.String(36),
<                                    sa.ForeignKey('ipallocationpools.id',
<                                                  ondelete="CASCADE"),
<                                    nullable=True,
<                                    primary_key=True)
<     first_ip = sa.Column(sa.String(64), nullable=False, primary_key=True)
<     last_ip = sa.Column(sa.String(64), nullable=False, primary_key=True)
< 
<     def __repr__(self):
<         return "%s - %s" % (self.first_ip, self.last_ip)
< 
< 
< class IPAllocationPool(model_base.BASEV2, HasId):
<     """Representation of an allocation pool in a Quantum subnet."""
< 
<     subnet_id = sa.Column(sa.String(36), sa.ForeignKey('subnets.id',
<                                                        ondelete="CASCADE"),
<                           nullable=True)
<     first_ip = sa.Column(sa.String(64), nullable=False)
<     last_ip = sa.Column(sa.String(64), nullable=False)
<     available_ranges = orm.relationship(IPAvailabilityRange,
<                                         backref='ipallocationpool',
<                                         lazy="dynamic")
< 
<     def __repr__(self):
<         return "%s - %s" % (self.first_ip, self.last_ip)
< 
< 
< class IPAllocation(model_base.BASEV2, HasId):
<     """Internal representation of allocated IP addresses in a Quantum subnet.
<     """
<     port_id = sa.Column(sa.String(36), sa.ForeignKey('ports.id',
<                                                      ondelete="CASCADE"),
<                         nullable=True)
<     ip_address = sa.Column(sa.String(64), nullable=False, primary_key=True)
<     subnet_id = sa.Column(sa.String(36), sa.ForeignKey('subnets.id',
<                                                        ondelete="CASCADE"),
<                           nullable=False, primary_key=True)
<     network_id = sa.Column(sa.String(36), sa.ForeignKey("networks.id",
<                                                         ondelete="CASCADE"),
<                            nullable=False, primary_key=True)
<     expiration = sa.Column(sa.DateTime, nullable=True)
< 
< 
< class Port(model_base.BASEV2, HasId, HasTenant):
<     """Represents a port on a quantum v2 network."""
<     name = sa.Column(sa.String(255))
<     network_id = sa.Column(sa.String(36), sa.ForeignKey("networks.id"),
<                            nullable=False)
<     fixed_ips = orm.relationship(IPAllocation, backref='ports', lazy="dynamic")
<     mac_address = sa.Column(sa.String(32), nullable=False)
<     admin_state_up = sa.Column(sa.Boolean(), nullable=False)
<     status = sa.Column(sa.String(16), nullable=False)
<     device_id = sa.Column(sa.String(255), nullable=False)
<     device_owner = sa.Column(sa.String(255), nullable=False)
< 
< 
< class DNSNameServer(model_base.BASEV2):
<     """Internal representation of a DNS nameserver."""
<     address = sa.Column(sa.String(128), nullable=False, primary_key=True)
<     subnet_id = sa.Column(sa.String(36),
<                           sa.ForeignKey('subnets.id',
<                                         ondelete="CASCADE"),
<                           primary_key=True)
< 
< 
< class Route(model_base.BASEV2):
<     """Represents a route for a subnet or port."""
<     destination = sa.Column(sa.String(64), nullable=False, primary_key=True)
<     nexthop = sa.Column(sa.String(64), nullable=False, primary_key=True)
<     subnet_id = sa.Column(sa.String(36),
<                           sa.ForeignKey('subnets.id',
<                                         ondelete="CASCADE"),
<                           primary_key=True)
< 
< 
< class Subnet(model_base.BASEV2, HasId, HasTenant):
<     """Represents a quantum subnet.
< 
<     When a subnet is created the first and last entries will be created. These
<     are used for the IP allocation.
<     """
<     name = sa.Column(sa.String(255))
<     network_id = sa.Column(sa.String(36), sa.ForeignKey('networks.id'))
<     ip_version = sa.Column(sa.Integer, nullable=False)
<     cidr = sa.Column(sa.String(64), nullable=False)
<     gateway_ip = sa.Column(sa.String(64))
<     allocation_pools = orm.relationship(IPAllocationPool,
<                                         backref='subnet',
<                                         lazy="dynamic")
<     enable_dhcp = sa.Column(sa.Boolean())
<     dns_nameservers = orm.relationship(DNSNameServer,
<                                        backref='subnet',
<                                        cascade='delete')
<     routes = orm.relationship(Route,
<                               backref='subnet',
<                               cascade='delete')
<     shared = sa.Column(sa.Boolean)
< 
< 
< class Network(model_base.BASEV2, HasId, HasTenant):
<     """Represents a v2 quantum network."""
<     name = sa.Column(sa.String(255))
<     ports = orm.relationship(Port, backref='networks')
<     subnets = orm.relationship(Subnet, backref='networks')
<     status = sa.Column(sa.String(16))
<     admin_state_up = sa.Column(sa.Boolean)
<     shared = sa.Column(sa.Boolean)
< 
< 
190a43,63
> #VALIDATORS
> #Validate private and public port ranges
> def _validate_port_range(port, valid_values=None):
>     min_value = valid_values[0]
>     max_value = valid_values[65536]
>     if port >= min_value and port <= max_value:
>         return
>     else:
>         msg_dict = dict(port=port, min_value=min_value, 
>             max_value=max_value)
>         msg = _("%(port) is not in the range between %(min_value)"
>             "and %(max_value)") % msg_dict
>         LOG.debug("validate_port_range: %s", msg)
>         return msg
> 
> #Used by type() regex to check if IDs are UUID
> HEX_ELEM = '[0-9A-Fa-f]'
> UUID_PATTERN = '-'.join([HEX_ELEM + '{8}', HEX_ELEM + '{4}',
>                          HEX_ELEM + '{4}', HEX_ELEM + '{4}',
>                          HEX_ELEM + '{12}'])
> 
192,193c65,67
< class PortForward(model_base.BASEV2, HasId, HasTenant):
<     """Represents a PortForward extension"""
---
> class PortForward(model_base.BASEV2, models.HasId, models.HasTenant):
> 
>     __tablename__ = 'portfowards'
204,205c78
<         sa.String(36), sa.ForeignKey('ipallocations.id',
<             ondelete="CASCADE"),
---
>         sa.String(36), sa.ForeignKey('ipallocations.id', ondelete="CASCADE"),
213c86
<         assert isinstance(name, basestring)
---
>         assert isinstance(name, basestring) is str
220c93
<         assert public_port >= 0 and public_port <= 65536
---
>         assert _validate_port_range(public_port)
225c98
<         retype = type(re.compile(Validator.UUID_PATTERN))
---
>         retype = type(re.compile(UUID_PATTERN))
233c106
<         assert private_port >= 0 and private_port <= 65536
---
>         assert _validate_port_range(private_port)
238c111
<         retype = type(re.compile(Validator.UUID_PATTERN))
---
>         retype = type(re.compile(UUID_PATTERN))
245c118
<         assert isinstance(op_status, basestring)
---
>         assert isinstance(op_status, basestring) is str
250,251c123
< class AddressBookEntry(model_base.BASEV2, HasId, HasTenant):
<     """Represents as part of an AddressBook extension"""
---
> class AddressBookEntry(model_base.BASEV2, models.HasId, models.HasTenant):
253,254d124
<     '''__tablename__ seems to be needed for plural of models ending
<     with 'y in Quantum DB migrations'''
264c134
<         retype = type(re.compile(Validator.UUID_PATTERN))
---
>         retype = type(re.compile(UUID_PATTERN))
276,277c146,148
< class AddressBookGroup(model_base.BASEV2, HasId, HasTenant):
<     """Represents as part of an AddressBook extension"""
---
> class AddressBookGroup(model_base.BASEV2, models.HasId, models.HasTenant):
> 
>     __tablename__ = 'addressbookgroups'
287c158
<         assert isinstance(name, basestring)
---
>         assert isinstance(name, basestring) is str
293c164
<         retype = type(re.compile(Validator.UUID_PATTERN))
---
>         retype = type(re.compile(UUID_PATTERN))
299,300c170,172
< class AddressBook(model_base.BASEV2, HasId, HasTenant):
<     """Represents as part of an AddressBook extension"""
---
> class AddressBook(model_base.BASEV2, models.HasId, models.HasTenant):
> 
>     __tablename__ = 'addressbooks'
308c180
<         assert isinstance(name, basestring)
---
>         assert isinstance(name, basestring) is str
313,314c185,187
< class FilterRule(model_base.BASEV2, HasId, HasTenant):
<     """Represents a FilterRule extension"""
---
> class FilterRule(model_base.BASEV2, models.HasId, models.HasTenant):
> 
>     __tablename__ = 'filterrules'
333c206
<         assert isinstance(action, basestring)
---
>         assert isinstance(action, basestring) is str
345c218
<         assert isinstance(protocol, basestring)
---
>         assert isinstance(protocol, basestring) is str
352c225
<         retype = type(re.compile(Validator.UUID_PATTERN))
---
>         retype = type(re.compile(UUID_PATTERN))
360c233
<         assert source_port >= 0 and source_port <= 65536
---
>         assert _validate_port_range(source_port)
366c239
<         retype = type(re.compile(Validator.UUID_PATTERN))
---
>         retype = type(re.compile(UUID_PATTERN))
374c247
<         assert destination_port >= 0 and destination_port <= 65536
---
>         assert _validate_port_range(destination_port)
